<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>05 - Wykrywanie krawdzi</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="_static/github-markdown.css" />
  <link rel="stylesheet" href="_static/custom.css" />
  <link rel="icon" type="image/x-icon" href="_static/favicon.ico" />
  <script>
  MathJax = {
      tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
      fontCache: 'global'
      }
  };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<main class="markdown-body">
<header id="title-block-header">
<h1 class="title">05 - Wykrywanie krawdzi</h1>
</header>
<h1 id="wprowadzenie-do-przetwarzania-obraz贸w">Wprowadzenie do przetwarzania obraz贸w</h1>
<h2 id="politechnika-poznaska-instytut-robotyki-i-inteligencji-maszynowej">Politechnika Poznaska, Instytut Robotyki i Inteligencji Maszynowej</h2>
<p align="center">
  <img width="180" height="180" src="_static/logo.svg">
</p>

<h2 id="wiczenie-laboratoryjne-5-wykrywanie-krawdzi"><strong>wiczenie laboratoryjne 5: Wykrywanie krawdzi</strong></h2>
<p><a href="/lab-wdpo">Powr贸t do spisu treci wicze laboratoryjnych</a></p>
<h2 id="pochodne-czstkowe">Pochodne czstkowe</h2>
<p>Obraz cyfrowy mo偶e by traktowany jako dwuwymiarowa funkcja dyskretna. Wszelkiego rodzaju krawdziom na obrazie towarzyszy zmiana wartoci intensywnoci obrazu. Do wyliczenia pochodnych czstkowych mo偶na wykorzysta maski Prewitta (dla zmian pionowych i poziomych) lub Sobela (dla zmian skonych).</p>
<ul>
<li><p><strong>Maska Prewitta</strong></p>
<p>Umo偶liwia obliczenie pochodnych w dw贸ch podstawowych kierunkach. $$ \mathbf{M_x} = \begin{bmatrix} 1 &amp; 0 &amp; -1 \\ 1 &amp; \underline{0} &amp; -1 \\ 1 &amp; 0 &amp; -1 \end{bmatrix}, \mathbf{M_y} = \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 0 &amp; \underline{0} &amp; 0 \\ -1 &amp; -1 &amp; -1 \end{bmatrix} $$</p>
<p>Pochodne kierunkowe uzyskuje si poprzez splot obrazu z odpowiedni mask i podzielenie wyniku przez 3.</p></li>
<li><p><strong>Maska Sobela</strong></p>
<p>Podobnie jak maska Prewitta umo偶liwia obliczenie pochodnych w dw贸ch podstawowych kierunkach, jednak waga centralnego wiersza lub kolumny jest wy偶sza. $$ \mathbf{M_x} = \begin{bmatrix} 1 &amp; 0 &amp; -1 \\ 2 &amp; \underline{0} &amp; -2 \\ 1 &amp; 0 &amp; -1 \end{bmatrix}, \mathbf{M_y} = \begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 0 &amp; \underline{0} &amp; 0 \\ -1 &amp; -2 &amp; -1 \end{bmatrix} $$</p></li>
</ul>
<p>Pochodne kierunkowe uzyskuje si poprzez splot obrazu z odpowiedni mask i podzielenie wyniku przez 4. Przykadowy obraz i wartoci bezwzgldne gradient贸w wyznaczone filtrem Sobela przedstawiono poni偶ej.</p>
<p align="center">
  <img src="./_05 - Wykrywanie krawdzi_readme_files/filtering_results.png" />
</p>

<p><span class="emoji" data-emoji="boom"></span> <strong>Zadanie do wykonania</strong> <span class="emoji" data-emoji="boom"></span></p>
<p>Napisz program umo偶liwiajcy wczytanie pliku graficznego w skali szaroci, a nastpnie obliczenie pochodnych czstkowych za pomoc maski Prewitta i Sobela (nale偶y wykorzysta funkcj <code>cv2.filter2D</code>).</p>
<blockquote>
<p><strong>Uwaga:</strong><br />
Wykorzystaj typ <code>np.float32</code> w celu przechowania wynik贸w dziaania funkcji <code>cv2.filter2D</code>. <a href="https://docs.opencv.org/5.x/d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04">Dokumentacja dla funkcji</a>.</p>
</blockquote>
<h2 id="modu-i-kierunek-gradientu">Modu i kierunek gradientu</h2>
<p>Jednym ze sposob贸w ledzenia zmian jasnoci na obrazie jest analiza gradientu funkcji obrazowej (zar贸wno jego moduu jak i orientacji). Operator gradientu funkcji dwuwymiarowej mo偶na przedstawi w nastpujcy spos贸b: $$ \nabla=\left[\begin{array}{c} \frac{\delta}{\delta x} \ \frac{\delta}{\delta y} \end{array}\right] $$</p>
<p>Po zastosowaniu go do funkcji przybiera form:</p>
<p>$$ \nabla \mathrm{f}=\left[\begin{array}{c} \frac{\delta}{\delta x} f \ \frac{\delta}{\delta y} f \end{array}\right] $$</p>
<p>Dla tak zdefiniowanego gradientu mo偶na (jak dla ka偶dego wektora) okreli modu $|\nabla f|$ i orientacj $\Phi(\nabla f)$. Warto moduu daje informacj o sile krawdzi, a orientacja o jej kierunku (wskazuje kt prostopady do krawdzi). Z faktu, 偶e r贸偶niczkowanie jest operacj cig, a obrazy s dwuwymiarow funkcj dyskretn wynika konieczno aproksymacji r贸偶niczkowania. Operacja r贸偶niczkowania jest liniowa i niezale偶na od przesunicia, dlatego zazwyczaj realizuje si j przez splot z odpowiedni mask.</p>
<p>Modu gradientu wyznacza si jako pierwiastek z sumy kwadrat贸w pochodnych kierunkowych. czy on informacj o gradientach czstkowych w punkcie obrazu. Kierunek gradientu wyznacza kierunek spadku funkcji obrazowej w punkcie. Modu i kierunek gradientu wyra偶one s wzorami:</p>
<p>$$ \begin{array}{c} M(x, y)=\sqrt{M_{x}(x, y)^{2}+M_{y}(x, y)^{2}} \end{array} $$</p>
<p>$$ \begin{array}{c} \theta(x, y)=\arctan \left(\frac{M_{y}(x, y)}{M_{x}(x, y)}\right) \end{array} $$</p>
<p><span class="emoji" data-emoji="boom"></span> <strong>Zadanie do wykonania</strong> <span class="emoji" data-emoji="boom"></span></p>
<p>Dla wyliczonych wczeniej pochodnych, oblicz i wywietl obraz moduu gradientu.</p>
<blockquote>
<p><strong>Uwaga:</strong><br />
Przed wywietleniem nale偶y przeskalowa zakres wartoci do <code>0..255</code> - w tym celu wykorzystaj funkcj <a href="https://numpy.org/doc/stable/reference/generated/numpy.amax.html">np.amax</a>. Nastpnie przekonwertuj obraz do <code>uint8</code> korzystajc z metody <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.astype.html">astype</a>.</p>
</blockquote>
<h2 id="wykrywanie-krawdzi---metoda-cannyego">Wykrywanie krawdzi - metoda Cannyego</h2>
<p>Efekt zastosowania wikszoci detektor贸w opartych o gradient jest niezadowalajcy. Aby wykry krawdzie nale偶y progowa uzyskany wynik. Zbyt niski pr贸g prowadzi do powstania wielu artefakt贸w, zbyt wysoki powoduje przerywanie segment贸w. Problem ten jest czciowo rozwizany przez zastosowanie detektora Canny'ego. Jego dziaanie mo偶na podzieli na 4 etapy:</p>
<ul>
<li><p>Wygadzanie - obraz wejciowy jest wygadzany za pomoc filtru Gaussowskiego.</p></li>
<li><p>Wyznaczanie gradientu - wyznaczany jest modu gradientu obrazu.</p></li>
<li><p>Tumienie wartoci niemaksymalnych - wartoci gradientu prostopade do krawdzi s tumione. Przez "prostopade" rozumie si tu le偶ce w kierunku gradientu. W ten spos贸b wygaszane s wszystkie punkty, kt贸re nie le偶 na grzbiecie wyznaczonego obrazu moduu gradientu.</p>
  <p align="center">
  <img src="./_05 - Wykrywanie krawdzi_readme_files/canny_nms.png" />
  </p>
</li>
<li><p>Uciglanie - wykrywanie krawdzi dziaa na zasadzie histerezy. Okrelane s dwa progi. Piksele o wartoci moduu gradientu wikszej od wikszego progu s automatycznie traktowane jako krawdzie. Piksele o wartoci moduu mniejszej od mniejszego progu s automatycznie odrzucane. Piksele wartoci moduu znajdujcej si pomidzy progami s akceptowane tylko je偶eli ssiaduj z pikselem nale偶cym do krawdzi.</p>
<p>Dla zilustrowania przedstawiono poni偶ej przebieg wartoci funkcji. Jeli kolorem niebieskim oznaczymy pr贸g wy偶szy, a czerwonym pr贸g ni偶szy, wartoci oznaczone na czarno zostan pozostawione, szare - odrzucone.</p>
  <p align="center">
      <img src="./_05 - Wykrywanie krawdzi_readme_files/canny_thresholding.png" />
  </p>
</li>
</ul>
<p>W praktyce kroki 1 i 2 s wykonywane r贸wnoczenie przez zastosowanie operatora Sobela.</p>
<p><span class="emoji" data-emoji="boom"></span> <strong>Zadanie do wykonania</strong> <span class="emoji" data-emoji="boom"></span></p>
<p>Napisz program wykrywajcy krawdzie w obrazie metoda Cannyego (nale偶y wykorzysta funkcj <code>cv2.Canny</code>). Zbadaj wpyw r贸偶nych ustawie prog贸w. Do wybierania poziomu prog贸w wykorzystaj poznan wczeniej fukcjonalno suwak贸w (trackbar).</p>
<h2 id="wykrywanie-linii-prostych-oraz-okrg贸w-przy-pomocy-transformaty-hougha">Wykrywanie linii prostych oraz okrg贸w przy pomocy transformaty Hougha</h2>
<p><strong>Wykrycie prostej linii</strong> na obrazie mo偶e w znaczcy spos贸b uproci jego analiz. Jedn z metod stosowanych do detekcji linii prostych w obrazie jest transformata Hougha. Zakada ona, 偶e przez ka偶dy punkt obrazu przechodzi nieskoczenie wiele prostych opisanych r贸wnaniem:</p>
<p>$$ \rho=x \cos (\theta)+y \sin (\theta) $$</p>
<p>Zilustrowano to na rysunku poni偶ej:</p>
<p align="center">
    <img src="./_05 - Wykrywanie krawdzi_readme_files/hough.png" />
</p>

<p>Ka偶dej linii odpowiada jeden punkt w przestrzeni parametr贸w $\rho$, $\theta$, bo dla ka偶dej linii mamy jedn, unikaln par wartoci tych parametr贸w. Linie przechodzce przez ten sam punkt s zmienne tylko ze wzgldu na parametr $\theta$, wic wszystkie linie przechodzce przez punkt tworz w przestrzeni parametr贸w sinusoid. Mo偶na wic powiedzie, 偶e reprezentacj punktu w przestrzeni obrazu jest w przestrzeni parametr贸w sinusoida.</p>
<p>Odwr贸my teraz sytuacj. Jeli mamy punkt w przestrzeni parametr贸w $\rho$, $\theta$, co jest jego reprezentacj w przestrzeni obrazu? Ustalenie ka偶dego z parametr贸w $\rho$ i $\theta$ na pewn sta warto daje nam w dziedzinie zmiennych $x$ i $y$ r贸wnanie funkcji.</p>
<p>Za贸偶my teraz, 偶e wyznaczylimy algorytmem Cannyego krawdzie w obrazie. Dla ka偶dego punktu krawdzi o wsp贸rzdnych x i y wyznaczamy reprezentacj w przestrzeni parametr贸w. Ka偶d tak wyznaczon reprezentacj akumulujemy (nowy stan akumulatora = stary stan akumulatora + reprezentacja w przestrzeni parametr贸w).</p>
<p>Przykadem wykonania transformaty dla wszystkich punkt贸w obrazu (w przestrzeni parametr贸w $\rho$, $\theta$) jest wykres jak na rysunku poni偶ej:</p>
<p align="center">
    <img src="./_05 - Wykrywanie krawdzi_readme_files/hough_chart.png" />
</p>

<p>Liczba pikseli dzielcych taki sam wz贸r prostej przedstawiona jest jako jasno w obrazie. Punkty o najwikszej jasnoci to te, dla kt贸rych istnieje najwicej punkt贸w wspierajcych. Dlatego wanie obraz wyniku transformaty nazywa si akumulatorem, a metod wyboru gosowaniem.</p>
<p><strong>Detekcji okrg贸w</strong> dokonuje si w podobny spos贸b, co detekcji prostych. Do opisu okrgu wykorzystuje si trzy parametry $(x, y, r)$ zgodnie z r贸wnaniem:</p>
<p>$$r^{2}=(a-x)^{2}+(b-y)^{2}$$</p>
<p>Gdzie $a$ i $b$ to zmienne, $r$ to promie okrgu, a $x$ i $y$ to wsp贸rzdne jego rodka.</p>
<p><span class="emoji" data-emoji="boom"></span> <strong>Zadanie do wykonania</strong> <span class="emoji" data-emoji="boom"></span></p>
<p>Napisz program wykrywajcy w obrazie linie proste oraz okrgi (wykorzysta funkcje <code>HoughLines</code>, <code>HoughLinesP</code>, <code>HoughCircles</code>). Do test贸w mo偶na wykorzysta obraz <a href="https://chmura.put.poznan.pl/s/6qs8alOTP7engeZ">shapes.jpg</a>. Jako wz贸r wykorzystaj tutorial <a href="https://docs.opencv.org/5.x/d6/d10/tutorial_py_houghlines.html">dla linii</a> oraz <a href="https://docs.opencv.org/5.x/da/d53/tutorial_py_houghcircles.html">dla okrg贸w</a>.</p>
<blockquote>
<p><strong>Uwaga!</strong><br />
Zwr贸 szczeg贸ln uwag na to jak zwracane s poo偶enia wykrytych linii i okrg贸w - przyda si to w kolejnych zadaniach.</p>
</blockquote>
<h2 id="zadania-do-samodzielnej-realizacji">Zadania do samodzielnej realizacji</h2>
<p><span class="emoji" data-emoji="boom"></span> <strong>Zadanie do wykonania</strong> <span class="emoji" data-emoji="boom"></span></p>
<p>Napisz program, kt贸ry mo偶liwie dobrze nakreli granice statku na zdjciu dla autonomicznie ldujcej rakiety. Wykorzystaj jako wejcie obraz <a href="https://chmura.put.poznan.pl/s/QgcNTELTqe6G1gU">drone_ship.jpg</a>.</p>
<p><span class="emoji" data-emoji="boom"></span> <strong>Zadanie do wykonania</strong> <span class="emoji" data-emoji="boom"></span></p>
<p>Napisz program oznaczajcy automatycznie pomaracze i jabka dla sortowni owoc贸w. Wykorzystaj jako wejcie obraz <a href="https://chmura.put.poznan.pl/s/3jdBnO0dn3p9tKj">fruit.jpg</a>. Dla robota zbierajcego wystarczy, 偶e owoce dw贸ch rodzaj贸w bd otoczone obw贸dkami w r贸偶nych kolorach.</p>
<p><span class="emoji" data-emoji="boom"></span> <strong>Zadanie do wykonania</strong> <span class="emoji" data-emoji="boom"></span></p>
<p>Policz automatycznie jaka kwota znajduje si na obrazie <a href="https://chmura.put.poznan.pl/s/QEqdO0ak5pUYI9F">coins.jpg</a>. Sum monet wywietl w terminalu z dokadnoci do 2 miejsc po przecinku, wykorzystujc <a href="https://zetcode.com/python/fstring/">f-string</a>.</p>
</main>
</body>
</html>
